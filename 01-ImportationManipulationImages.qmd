---
jupyter: python3
from: markdown+emoji
execute:
  echo: true
  eval: false
  message: false
  warning: false
---
# Importation et manipulation de donn√©es spatiales {#sec-chap01}

## :rocket: Pr√©ambule
Assurez-vous de lire ce pr√©ambule avant d'ex√©cutez le reste du notebook.
### :dart: Objectifs
Dans ce chapitre, nous abordons quelques formats d'images ainsi que leur lecture. Ce chapitre est aussi disponible sous la forme d'un notebook Python:

[![](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/sfoucher/TraitementImagesPythonVol1/blob/main/notebooks/01-ImportationManipulationImages.ipynb){target="_blank"}  

### Librairies
Les librairies qui vont √™tre explor√©es dans ce chapitre sont les suivantes:

* scipy

* numpy 

* opencv

* rasterio 

* [rioxarray](https://corteva.github.io/rioxarray/stable/index.html)

* xarray


Dans l'environnement Google Colab, seul `rioxarray` et gdal doivent √™tre install√©:
```{python}
!apt-get update
!apt-get install gdal-bin libgdal-dev
!pip install -q rioxarray
```
V√©rifier les importations:
```{python}
#| eval: true
import numpy as np
import rioxarray as rxr
from scipy import signal
import xarray as xr
import xrscipy
import matplotlib.pyplot as plt
```
### Donn√©es

Nous allons utilis√©s ces images dans ce chapitre:
```{python}
!wget https://github.com/sfoucher/TraitementImagesPythonVol1/raw/refs/heads/main/data/chapitre01/subset_RGBNIR_of_S2A_MSIL2A_20240625T153941_N0510_R011_T18TYR_20240625T221903.tif -O RGBNIR_of_S2A.tif
!wget https://github.com/sfoucher/opengeos-data/raw/refs/heads/main/raster/landsat7.tif -O landsat7.tif
!wget https://github.com/sfoucher/opengeos-data/raw/refs/heads/main/images/berkeley.jpg -O berkeley.jpg
!wget https://raw.githubusercontent.com/sfoucher/TraitementImagesPythonVol1/refs/heads/main/images/modis-aqua.PNG -O modis-aqua.PNG
```
V√©rifiez que vous √™tes capable de les lire :
```{python}
#| eval: true
#| output: false

with rxr.open_rasterio('berkeley.jpg', mask_and_scale= True) as img_rgb:
    print(img_rgb)
with rxr.open_rasterio('RGBNIR_of_S2A.tif', mask_and_scale= True) as img_rgbnir:
    print(img_rgbnir)
```
## Importation d'images

La premi√®re √©tape avant tout traitement est d'acc√©der √† la donn√©e image pour qu'elle soit manipul√©e par le programme Python. L'imagerie satellite pr√©sente certains d√©fis notamment en raison de la taille parfois tr√®s importante des images. Il existe maintenant certaines librairies, comme üîñ[Xarray](https://docs.xarray.dev/en/stable/), qui on cherch√©es √† optimiser la lecture et l'√©criture de grandes images. Il est donc conseiller de toujours garder un oeil sur l'espace m√©moire occup√© par les variables Python reli√©es aux images. La librairie principale en g√©omatique qui va nous permettre d'importer (et d'exporter) de l'imagerie est la librairie [GDAL](https://gdal.org) qui rassemble la plupart des formats sous forme de *driver* (ou pilote en fran√ßais). 

Dans le domaine de la g√©omatique, il faut pr√™ter attention √† trois caract√©ristiques principales des images:
1. **La matrice des donn√©es** elle-m√™me qui contient les valeurs brutes des pixels. Cette matrice sera souvent un cube √† trois dimensions. En Python, ce cube sera le plus souvent un objet de la librairie üîñ[NumPy](https://numpy.org/) (voir section).
2. **La dynamique des images** c.√†.d le format de stockage des valeurs individuelles (octet, entier, double, etc.). Ce format d√©cide principalement de la r√©solution radiom√©trique et des valeurs minimales et maximales support√©es. 
3. **La m√©tadonn√©e** qui va transporter l'information auxiliaire de l'image comme les dimensions et la position de l'image, la date, etc. Cette donn√©e auxiliaire prendra souvent la forme d'un dictionnaire Python. 

Les diff√©rents formats se distinguent principalement sur la mani√®re dont ces trois caract√©ristiques sont g√©r√©es.

### Formats des images

Il existe maintenant de nombreux formats num√©riques pour la donn√©e de type image parfois appel√© donn√©e matricielle ou donn√©e *raster*. La librairie GDAL rassemble la plupart des formats matriciels rencontr√©s en g√©omatique (voir üîñ[Raster drivers ‚Äî GDAL documentation](https://gdal.org/en/latest/drivers/raster/index.html) pour une liste compl√®te).

On peut distinguer deux grandes familles de format:
1. Les formats de type **RVB** issus de l'imagerie num√©rique grand publique comme üîñ[JPEG](https://gdal.org/en/latest/drivers/raster/jpeg.html#raster-jpeg), [png](https://gdal.org/en/latest/drivers/raster/png.html#raster-png), etc. Ces formats ne supportent g√©n√©ralement que trois bandes au maximum (rouge, vert et bleu) et des valeurs de niveaux de gris entre 0 et 255 (format dit 8 bit).
2. **Les g√©o-formats** issus des domaines scientifiques ou techniques comme GeoTIFF, HDF5, etc. qui peuvent inclure plus que trois bandes et des dynamiques plus √©lev√©es (16 bit ou m√™me float).

Les formats RVB restent tr√®s utilis√©s en Python notamment par les librairies dites de vision par ordinateur (*Computer Vision*) comme OpenCV et sickit-image ainsi que les grandes librairies en apprentissage profond (PyTorch, Tensorflow).  

::: bloc_package
::: bloc_package-header
::: bloc_package-icon
:::

**Installation de gdal dans un syst√®me Linux **
:::

::: bloc_package-body
-   Pour installer GDAL¬†:
```
!apt-get update
!apt-get install gdal-bin libgdal-dev
```
:::
:::


#### Formats de type RVB 

Les premiers formats pour de l'imagerie √† une bande (monochrome) et √† trois bandes (image couleur rouge-vert-bleu) sont issus du domaine des sciences de l'ordinateur. On trouvera, entre autres, les formats pbm, png et jpeg. Ces formats supportent peu de m√©tadonn√©es et sont plac√©es dans un ent√™te (*header*) tr√®s limit√©. Cependant, ces formats restent tr√®s populaires dans le domaine de la vision par ordinateur et sont tr√®s utilis√©s en apprentissage profond en particulier. Pour la lecture des images RVB, on peut utiliser les librairies Rasterio, [PIL](https://he-arc.github.io/livre-python/pillow/index.html) ou [OpenCV](https://docs.opencv.org/4.10.0/index.html).

##### Lecture avec la librairie PIL
La librairie PIL retourne un objet de type `PngImageFile`, l'affichage de l'image se fait directement dans la cellule de sortie.

```{python}
#| lst-label: lst-lecture-PIL-PNG
#| lst-cap: Lecture d'une image en format PNG avec PIL
#| eval: true

from PIL import Image
img = Image.open('modis-aqua.PNG')
img
```

##### Lecture avec la librairie OpenCV
La librairie [OpenCV](https://docs.opencv.org/4.10.0/index.html) est aussi tr√®s populaire en vision par ordinateur. La fonction `imread` donne directement un objet de type NumPy en sortie.

```{python}
#| lst-label: lst-lecture-opencv-PNG
#| lst-cap: Lecture d'une image en format PNG avec OpenCV

import cv2
img = cv2.imread('modis-aqua.PNG')
img
```
##### Lecture avec la librairie RasterIO

Rien ne nous emp√™che de lire une image de format RVB avec [RasterIO](https://rasterio.readthedocs.io/en/stable/) comme d√©crit dans (@lst-lecturerasterioPNG). Vous noterez cependant les avertissements concernant l'absence de g√©or√©f√©rence pour ce type d'image.

```{python}
#| lst-label: lst-lecturerasterioPNG
#| lst-cap: Lecture d'une image en format PNG avec OpenCV

import rasterio
img= rasterio.open('modis-aqua.PNG')
img
```

#### Le format GeoTiff 

Le format GeoTIFF est une extension du format TIFF (Tagged Image File Format) qui permet d'incorporer des m√©tadonn√©es g√©ospatiales directement dans un fichier image. D√©velopp√© initialement par Dr. Niles Ritter au Jet Propulsion Laboratory de la [NASA](https://www.earthdata.nasa.gov/esdis/esco/standards-and-practices/geotiff){target="_blank"} dans les ann√©es 1990, GeoTIFF est devenu un standard de facto pour le stockage et l'√©change d'images g√©or√©f√©renc√©es dans les domaines de la t√©l√©d√©tection et des syst√®mes d'information g√©ographique (SIG). Ce format supporte plus que trois bandes aussi longtemps que ces bandes sont de m√™me dimension.

Le format GeoTIFF est tr√®s utilis√© et est largement support√© par les biblioth√®ques et logiciels g√©ospatiaux, notamment [GDAL](https://gdal.org) (*Geospatial Data Abstraction Library*), qui offre des capacit√©s de lecture et d'√©criture pour ce format. Cette compatibilit√© √©tendue a contribu√© √† son adoption g√©n√©ralis√©e dans la communaut√© g√©ospatiale.

##### Standardisation par l'OGC 

Le standard GeoTIFF propos√© par l'Open Geospatial Consortium (OGC) en 2019 formalise et √©tend les sp√©cifications originales du format GeoTIFF, offrant une norme robuste pour l'√©change d'images g√©or√©f√©renc√©es. Cette standardisation, connue sous le nom d'OGC GeoTIFF 1.1 [-@OGCGeoTIFF], apporte plusieurs am√©liorations et clarifications importantes.


#### Le format COG

Une innovation r√©cente dans l'√©cosyst√®me GeoTIFF est le format *Cloud Optimized GeoTIFF* ([COG](http://cogeo.org/)), con√ßu pour faciliter l'utilisation de fichiers GeoTIFF h√©berg√©s sur des serveurs web HTTP. Le COG permet aux utilisateurs et aux logiciels d'acc√©der √† des parties sp√©cifiques du fichier sans avoir √† le t√©l√©charger enti√®rement, ce qui est particuli√®rement utile pour les applications bas√©es sur le cloud.

### M√©tadonn√©es des images 

La mani√®re la plus directe d'acc√©der √† la m√©tadonn√©e d'une image est d'utiliser les commandes üîñ[`rio info`](https://rasterio.readthedocs.io/en/stable/cli.html#info) de la librairie Rasterio ou `gdalinfo` de la librairie `gdal`. Le r√©sultat est imprim√© dans la sortie standard ou sous forme d'un dictionnaire Python.

```{python}
#| lst-label: lst-gdalinfo
#| lst-cap: Collecte d'information sur une image avec gdal
#| eval: true

!gdalinfo RGBNIR_of_S2A.tif
```

Le plus simple est d'utiliser la fonction `rio info`:
```{python}
#| lst-label: lst-rioinfo
#| lst-cap: Collecte d'information sur une image avec rasterio
#| eval: true

!rio info RGBNIR_of_S2A.tif --indent 2 --verbose
```

## Manipulation des images

### Manipulation de la matrice de pixels 

La donn√©e brute de l'image est g√©n√©ralement contenue dans un cube matricielle √† trois dimensions (deux dimensions spatiales et une dimension spectrale). Comme expos√© pr√©c√©demment, la librairie dite *"fondationnelle"* pour la manipulation de matrices en Python est [NumPy](https://numpy.org/). Cette librairie contient un nombre tr√®s important de fonctionnalit√©s couvrant l'alg√®bre lin√©aires, les statistiques, etc. et constitue la fondation de nombreuses librairies (voir (@fig-naturenumpy1))

![La librairie NumPy est le fondement de nombreuses librairies scientifiques (d'apr√®s [@NumpyNature]).](https://raw.githubusercontent.com/sfoucher/TraitementImagesPythonVol1/refs/heads/main/images/41586_2020_2649_Fig2_HTML.png){#fig-naturenumpy1 width="100%" fig-align="center"}

### Information de base

Les deux informations de base √† afficher sur une matrice sont 1) les dimensions de la matrice et 2) le format de stockage (le type). Pour cela, on peut utiliser le (@lst-numpyshape), le r√©sultat nous informe que la matrice a 3 dimensions et une taille de `(442, 553, 3)` et un type `uint8` qui repr√©sente 1 octet (8 bit). Par cons√©quent, la matrice a `442` lignes, `553` colonnes et `3` canaux ou bandes. Il faut pr√™ter une attention particuli√®re aux valeurs minimales et maximales tol√©r√©es par le type de la donn√©e comme indiqu√© dans le (@tbl-numpytype) (voir aussi üîñ[Data types ‚Äî NumPy v2.1 Manual](https://numpy.org/doc/stable/user/basics.types.html)).


```{python}
#| lst-label: lst-numpyshape
#| lst-cap: Lecture d'une image en format PNG avec OpenCV
#| eval: true

import cv2
img = cv2.imread('modis-aqua.PNG')
print('Nombre de dimensions: ',img.ndim)
print('Dimensions de la matrice: ',img.shape)
print('Type de la donn√©e: ',img.dtype)
```

```{python}
#| label: tbl-numpytype
#| tbl-cap: "Type de donn√©es de NumPy"
#| eval: true

from IPython.display import Markdown
from tabulate import tabulate
table = [["uint8", "char", 8, 0, 255],
        ["int8", "signed char", 8, -127, +128],
        ["uint16", "unsigned short", 16, 0, -32768, +32767],
        ["int16", "short", 16, 0, 655355]]
Markdown(tabulate(table, headers=["dtype", "Nom", "Taille (bits)", "Min", "Max"], tablefmt="pipe"))
```

::: bloc_aller_loin
::: bloc_aller_loin-header
::: bloc_aller_loin-icon
:::

**Les diff√©rents types de donn√©es en dans NumPy**
:::

::: bloc_aller_loin-body
Il comprend des r√©f√©rences ou des extensions d'une m√©thode abord√©e dans une section.
:::
:::

### D√©coupage et indexation de la matrice

L'indexation et le d√©coupage des matrices dans NumPy sont des techniques essentielles pour manipuler efficacement les donn√©es multidimensionnelles en Python, offrant une syntaxe puissante et flexible pour acc√©der et modifier des sous-ensembles sp√©cifiques d'√©l√©ments dans les tableaux (voir @fig-naturenumpy2). Indexer une matrice consiste √† acc√©der √† une valeur dans la matrice pour une position particuli√®re, la syntaxe g√©n√©rale est `matrice[ligne, colonne, bande]` et est similaire √† la manipulation des [listes](https://docs.python.org/fr/3/tutorial/introduction.html#lists) en Python. Les indices commencent √† `0` et se termine √† la `taille-1` de l'axe consid√©r√©. 

![Vue d'ensemble des op√©rations de base des matrices avec NumPy](https://raw.githubusercontent.com/sfoucher/TraitementImagesPythonVol1/refs/heads/main/images/41586_2020_2649_Fig1_HTML.png){#fig-naturenumpy2 width="100%" fig-align="center"}

Le d√©coupage (ou *slicing* en anglais) consiste √† produire une nouvelle matrice qui est un sous-ensemble de la matrice d'origine. Un d√©coupage se fait avec le symbole ':', la syntaxe g√©n√©rale pour d√©finir un d√©coupage est `[d√©but:fin:pas]`. Si on ne sp√©cifie pas `d√©but` ou `fin` alors les valeurs 0 ou `dimension-1` sont consid√©r√©es implicitement. Quelques exemples:
* choisir un pixel en particulier avec toutes les bandes: `matrice[1,1,:]`
* choisir la colonne 2: `matrice[:,2,:]`

La syntaxe de base pour le d√©coupage (*slicing*) des tableaux NumPy repose sur l'utilisation des deux-points (`:`) √† l'int√©rieur des crochets d'indexation. Cette notation permet de s√©lectionner des plages d'√©l√©ments de mani√®re concise et intuitive.
La structure g√©n√©rale du d√©coupage est `matrice[start:stop:step]`, o√π :
1. `start` repr√©sente l'index de d√©part (inclus)
2. `stop` indique l'index de fin (exclu)
3. `step` d√©finit l'intervalle entre chaque √©l√©ment s√©lectionn√©

Si l'un de ces param√®tres est omis, NumPy utilise des valeurs par d√©faut : 0 pour `start`, la taille du tableau pour `stop`, et 1 pour `step`. Par exemple, pour un tableau unidimensionnel `array`, on peut extraire les √©l√©ments du deuxi√®me au quatri√®me avec `array[1:4]`. Pour s√©lectionner tous les √©l√©ments √† partir du troisi√®me, on utiliserait `array[2:]`. Cette syntaxe s'applique √©galement aux tableaux multidimensionnels, o√π chaque dimension est s√©par√©e par une virgule. Ainsi, pour une matrice 2D m, `m[0:2, 1:3]` s√©lectionnerait une sous-matrice 2x2 compos√©e des deux premi√®res lignes et des deuxi√®me et troisi√®me colonnes. L'indexation n√©gative est √©galement support√©e, permettant de compter √† partir de la fin du tableau. Par exemple, `a[-3:]` s√©lectionnerait les trois derniers √©l√©ments d'un tableau.

```{python}
#| eval: true

import cv2
img = cv2.imread('modis-aqua.PNG')
img_col = img[:,1,:]
print('Nombre de dimensions: ',img_col.ndim)
print('Dimensions de la matrice: ',img_col.shape)
```

::: bloc_aller_loin
::: bloc_aller_loin-header
::: bloc_aller_loin-icon
:::

**Une vue versus une copie**
:::

::: bloc_aller_loin-body
Avec NumPy, les manipulations peuvent cr√©er des vues ou des copies. Une vue est une simple repr√©sentation de la m√™me donn√©e originale alors qu'une copie est un nouvel espace m√©moire.

Par d√©faut, un d√©coupage cr√©√© une vue.

On peut v√©rifier si l'espace m√©moire est partag√© avec `np.shares_memory(arr, slice_arr)`.

On peut toujours forcer une copie avec la m√©thode `copy()`
:::
:::
#### Exemple 1: calcul d'un rapport de bande

#### Exemple 2: application d'un filtrage spatial

### Mosa√Øquage, masquage et d√©coupage 

#### Masquage

L'utilisation d'un masque est un outil important en traitement d'image car la plupart des images de t√©l√©d√©tection contiennent des pixels non valides qu'il faut exclure des traitements (ce que l'on appelle le *no data* en Anglais). Il y a plusieurs raison possibles pour la pr√©sence de pixels non valides:
1. L'image est projet√©e dans une grille cartographique et certaines zones, g√©n√©ralement situ√©es en dehors de l'empreinte au sol du capteur, sont √† exclure.
2. La pr√©sence de nuages que l'on veut exclure.
3. La pr√©sence de pixels erron√©s d√ªs √† des probl√®mes de capteurs.
4. La pr√©sence de valeurs non num√©riques (*not a number* ou `nan`)
 

La librairie NumPy fournit des m√©canismes pour exclure automatiquement certaines valeurs.

### Changement de projection cartographique 

### Recalage d'images et co-registration 

## Donn√©es en g√©oscience

Les donn√©es en g√©oscience contiennent beaucoup de m√©tadonn√©es et peuvent √™tre compos√©es de diff√©rentes variables avec diff√©rentes unit√©s, r√©solution, etc.  Ces donn√©es sont aussi souvent √©tiquet√©es avec des dates sur certains axes, des coordonn√©es g√©ographiques, des identifiants d'exp√©riences, etc. Par cons√©quent, utiliser seulement des matrices est souvent incomplet [@xarray-2017].

Calibration, unit√©s, donn√©es manquantes, donn√©es √©parses.

### xarray

[Xarray](https://docs.xarray.dev/en/latest/getting-started-guide/why-xarray.html) est une puissante biblioth√®que Python qui am√©liore les matrices multidimensionnelles de type numpy en y ajoutant des √©tiquettes, des dimensions, des coordonn√©es et des attributs. Elle fournit deux structures de donn√©es principales : `DataArray` (un tableau √©tiquet√© √† N dimensions) et `Dataset` (une base de donn√©es de tableaux multidimensionnels en m√©moire).

Les caract√©ristiques principales sont les suivantes:

- Op√©rations sur les dimensions nomm√©es au lieu des num√©ros d'axe

- S√©lection et op√©rations bas√©es sur les √©tiquettes

- Diffusion automatique de tableaux bas√©e sur les noms de dimensions

- Alignement de type base de donn√©es avec des √©tiquettes de coordonn√©es

- Suivi des m√©tadonn√©es gr√¢ce aux dictionnaires Python

#### Avantages
La biblioth√®que r√©duit consid√©rablement la complexit√© du code et am√©liore la lisibilit√© du code pour les applications de calcul scientifique dans divers domaines, notamment la physique, l'astronomie, les g√©osciences, la bio-informatique, l'ing√©nierie, la finance et l'apprentissage profond. Elle s'int√®gre de mani√®re transparente avec NumPy et pandas tout en restant compatible avec l'√©cosyst√®me Python au sens large.


#### DataArray
Un tableau multidimensionnel √©tiquet√© avec des propri√©t√©s cl√©es :

- `valeurs` : Les donn√©es r√©elles du tableau

- `dims` : Dimensions nomm√©es (par exemple, ¬´ x ¬ª, ¬´ y ¬ª, ¬´ z ¬ª)

- `coords` : Dictionnaire de tableaux √©tiquetant chaque point

- `attrs` : Stockage de m√©tadonn√©es arbitraires

- `name` : Identifiant facultatif

#### Dataset 
Un conteneur de type dictionnaire de `DataArrays` avec des dimensions align√©es, contenant :

- `dims` : Dictionnaire de correspondance entre les noms des dimensions et les longueurs

- `data_vars` : Dictionnaire des variables du DataArray

- `coords` : Dictionnaire des variables de coordonn√©es

- `attrs` : Stockage des m√©tadonn√©es

Les principales diff√©rences sont les suivantes :
- DataArray contient un seul tableau avec des √©tiquettes
- Le Dataset contient plusieurs DataArrays align√©s.


Ces trois structures prennent en charge les op√©rations de type dictionnaire et les calculs de coordination tout en conservant les m√©tadonn√©es.

![](https://docs.xarray.dev/en/latest/_images/dataset-diagram.png)

netcdf, xarray, GRIB.

Donn√©es m√©t√©os, exemple avec SWOT.

## Importation de donn√©es vectorielles

### Importation d'un fichier *shapefile*

### Importation d'une couche dans un *GeoPackage*

### Importation d'une couche dans une *geodatabase* d'ESRI

### Importation d'un fichier *shapefile*

## Manipulation de donn√©es vectorielles

### Requ√™tes attributaires 

## Quiz de r√©vision du chapitre 

## Exercices de r√©vision 
